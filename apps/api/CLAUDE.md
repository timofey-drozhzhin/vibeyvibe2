# vibeyvibe API

Hono v4 REST API backend for the vibeyvibe music management system. Deploys to Bunny Edge Scripting as a single bundled file.

## Overview

The API is a Hono application that serves all data at the `/api` prefix. It uses Drizzle ORM with SQLite/libSQL for persistence, Better Auth for authentication, and Zod for request validation. The server runs on Node.js locally (via `@hono/node-server`) and deploys as an edge function to Bunny Edge Scripting.

All CRUD routes are generated by a factory function from a centralized registry of 13 entity configurations. Extension routes handle Spotify import, file upload, and file serving.

## Directory Structure

```
src/
├── index.ts              # Entry point: loads .env, starts @hono/node-server on port 3001
├── app.ts                # Hono app setup: middleware stack, auth handler, route mounting
├── env.ts                # Zod-validated environment variable schema and getEnv() singleton
├── auth/
│   └── index.ts          # Better Auth configuration (Drizzle adapter, Google OAuth, email/password)
├── db/
│   ├── index.ts          # Drizzle client factory with libSQL driver (getDb() singleton)
│   ├── schema.ts         # Unified Drizzle schema (ALL domain tables in one file)
│   ├── seed.ts           # Database seeding script — sample data + all 59 vibes (run via pnpm db:seed)
│   └── schema/
│       ├── index.ts      # Re-exports schema.ts + auth.ts
│       └── auth.ts       # Better Auth tables: user, session, account, verification
├── middleware/
│   ├── auth.ts           # Auth middleware: session validation, dev bypass, route skipping for /api/auth/*
│   ├── error.ts          # Global error handler: HTTPException mapping, 500 fallback
│   └── rate-limit.ts     # In-memory rate limiter (per IP, configurable window and max requests)
├── routes/
│   ├── index.ts          # Assembles factory-generated routes + extension routes + dashboard stats
│   ├── registry.ts       # All 13 entity-context route configs + inline Zod schemas + enricher functions
│   ├── factory/
│   │   ├── types.ts      # EntityRouteConfig, RelationshipRouteConfig, ExtraFilter type definitions
│   │   └── create-routes.ts # Generic CRUD route factory (generates GET list, GET detail, POST, PUT, relationships)
│   └── extensions/
│       ├── lab-import.ts   # Spotify import preview + confirm endpoints
│       ├── profile-generator.ts # AI profile generation (stores vibes as JSON in profiles table)
│       ├── profiles.ts   # Profile archive/restore endpoint
│       ├── suno-prompt-generator.ts # AI Suno prompt generation from profiles
│       ├── upload.ts     # File upload endpoint (multipart form data)
│       └── storage.ts    # File serving endpoint (static file delivery)
├── services/
│   ├── openrouter/
│   │   └── index.ts      # OpenRouter chat completion API wrapper (edge-compatible)
│   ├── spotify/
│   │   └── index.ts      # Spotify metadata extraction (uses spotify-url-info library)
│   └── storage/
│       ├── index.ts      # StorageClient interface + factory (createStorageClient)
│       ├── local.ts      # LocalStorageClient: filesystem-based storage for development
│       └── bunny.ts      # BunnyStorageClient: Bunny Edge Storage for production
└── types/
    └── spotify-url-info.d.ts # Type declarations for the spotify-url-info library
```

**Key architectural change**: All CRUD routes are generated by the factory from registry configurations. All Zod schemas are defined inline — in `routes/registry.ts` for factory routes, and in their respective extension route files for non-CRUD routes (e.g., `importUrlSchema` in `routes/extensions/lab-import.ts`). There are no separate validator files.

## Schema Rules

All domain tables are defined in a single unified file: `src/db/schema.ts`.

### Table Naming

Shared entity tables (`songs`, `artists`, `albums`) use a `context` column to differentiate sections. Context values are `"my_music"`, `"lab"`, `"bin"`, or `"suno"` depending on the entity.

Complete table inventory:

| Table Name | Type | Description |
|---|---|---|
| `songs` | Entity | Shared songs (context: `my_music` or `lab`) |
| `artists` | Entity | Shared artists (context: `my_music` or `lab`) |
| `albums` | Entity | Shared albums (context: `my_music` or `lab`) |
| `vibes` | Entity | Lab vibes (context: `lab`) |
| `bin_sources` | Entity | Bin collection sources (context: `bin`) |
| `bin_songs` | Entity | Bin song entries (context: `bin`) |
| `suno_prompt_collections` | Entity | Suno prompt collection groups (context: `suno`) |
| `suno_prompts` | Entity | Suno text prompts (context: `suno`) |
| `suno_song_playlists` | Entity | Suno song playlist groups (context: `suno`) |
| `suno_songs` | Entity | Suno generation outputs (context: `suno`) |
| `artist_songs` | Pivot | M:N link between artists and songs |
| `album_songs` | Pivot | M:N link between albums and songs |
| `suno_collection_prompts` | Pivot | M:N link between collections and prompts |
| `profiles` | Relational | 1:N from songs, stores AI-generated vibes as JSON |
| `user` | Auth | Better Auth user table |
| `session` | Auth | Better Auth session table |
| `account` | Auth | Better Auth account table |
| `verification` | Auth | Better Auth verification table |

### Base Entity Columns

All entity tables (NOT pivot tables) share these columns via the `baseEntityColumns` spread:

```typescript
const baseEntityColumns = {
  id: integer("id").primaryKey({ autoIncrement: true }),
  name: text("name").notNull(),
  context: text("context").notNull(),
  archived: integer("archived", { mode: "boolean" }).default(false),
  created_at: text("created_at").default(sql`CURRENT_TIMESTAMP`),
  updated_at: text("updated_at").default(sql`CURRENT_TIMESTAMP`),
};
```

### Primary Keys

All tables use `integer("id").primaryKey({ autoIncrement: true })`. No text/nanoid IDs. Pivot tables use composite primary keys (e.g., `primaryKey({ columns: [table.artist_id, table.song_id] })`).

### Column Naming

- All column names use **snake_case** (e.g., `image_path`, `release_date`, `spotify_uid`, `vibe_category`).
- Foreign keys use `_id` suffix (e.g., `song_id`, `artist_id`, `bin_source_id`, `suno_prompt_id`).
- External identifiers (platform IDs) use `_uid` suffix (e.g., `spotify_uid`, `apple_music_uid`, `youtube_uid`, `suno_uid`).

### Timestamps

Every table includes:
- `created_at` -- Set to `CURRENT_TIMESTAMP` by default
- `updated_at` -- Set to `CURRENT_TIMESTAMP` by default (auto-updated to `new Date().toISOString()` on every PUT by the route factory)

Domain tables use `text` columns with SQL `CURRENT_TIMESTAMP` defaults. Auth tables use `integer` columns with `{ mode: "timestamp" }` as required by Better Auth.

### Rating Scale

All rating fields use `real("rating")` with a **0-1 real scale** (0 = unrated, values between 0 and 1 represent the rating). Zod schemas in the registry currently validate `z.number().min(0).max(5)`. Present on: `songs`, `artists`, `albums`, `bin_songs`.

### Archive Flag

Every entity table includes `archived: integer("archived", { mode: "boolean" }).default(false)`. Records are never deleted; they are archived via PUT with `{ archived: true }`.

### Foreign Keys

Entity tables use `.references(() => parentTable.id)` for referential integrity. Pivot tables use `.references(() => parentTable.id, { onDelete: "cascade" })`. Composite primary keys on pivots prevent duplicate relationships.

### Indexes

Context columns are indexed on shared tables (`songs_context_idx`, `artists_context_idx`, `albums_context_idx`). Foreign key columns on entity tables have indexes (e.g., `bin_songs_bin_source_id_idx`). The `songs` table also indexes `isrc` and `spotify_uid` for duplicate detection during import.

### Drizzle Relations

All tables define Drizzle `relations()` exports for type-safe query building. Entity tables declare `many()` relations to their pivots/children. Pivot tables declare `one()` relations back to both parent entities.

## Route Factory

All CRUD routes are generated by the `createEntityRoutes(config)` function in `routes/factory/create-routes.ts`. This eliminates per-section route files.

### How It Works

1. Takes an `EntityRouteConfig` object (defined in `routes/factory/types.ts`)
2. Auto-generates a `listQuerySchema` from the config (page, pageSize, sort, order, search, archived, plus any extraFilters)
3. Derives an `updateSchema` from `createSchema.partial().extend({ archived })` unless an explicit `updateSchema` is provided
4. Registers extension routes first (if any) so they get priority over CRUD patterns
5. Generates four CRUD routes: `GET /`, `POST /`, `GET /:id`, `PUT /:id`
6. Generates relationship sub-routes for each configured relationship

### Auto-Behaviors

| Behavior | Description |
|---|---|
| **Context filtering** | If `contextColumnValue` is set, all queries (list, detail, update) auto-filter by `context = contextColumnValue` |
| **Context injection** | On POST, if `contextColumnValue` is set, the `context` field is auto-injected into the insert values |
| **updated_at** | On PUT, `updated_at` is auto-set to `new Date().toISOString()` |
| **Search** | By default searches `table.name` with LIKE. Override via `searchColumns` array, or set `searchColumns: null` to disable |
| **Extra filters** | Additional query params (e.g., `category`, `song_id`, `bin_source_id`) defined via `extraFilters` array |
| **List enrichment** | `listEnricher(db, rows)` callback batch-loads related data for list responses (e.g., artists for songs) |
| **Detail enrichment** | `detailEnricher(db, entity)` callback loads related data for single-record responses (e.g., artists + albums for a song) |

### EntityRouteConfig Type

```typescript
interface EntityRouteConfig {
  context: string;           // URL section prefix (e.g., "my-music", "lab", "bin", "suno")
  slug: string;              // URL resource name (e.g., "songs", "artists", "vibes")
  table: any;                // Drizzle table object
  entityName: string;        // Human name for error messages (e.g., "Song", "Artist")

  createSchema: z.ZodTypeAny;
  updateSchema?: z.ZodTypeAny;  // Default: createSchema.partial().extend({ archived })

  defaultSort: any;          // Drizzle column for default sort
  defaultOrder?: "asc" | "desc";
  sortableColumns: Record<string, any>;

  searchColumns?: any[] | null;  // Default: [table.name]. null = disable search.
  extraFilters?: ExtraFilter[];

  contextColumnValue?: string;   // Auto-filter/inject context (e.g., "my_music", "lab")

  listEnricher?: (db, rows) => Promise<any[]>;
  detailEnricher?: (db, entity) => Promise<Record<string, any>>;

  relationships?: RelationshipRouteConfig[];
  extensions?: (router: Hono) => void;
}
```

### RelationshipRouteConfig Type

```typescript
interface RelationshipRouteConfig {
  slug: string;          // URL path segment (e.g., "artists", "albums", "prompts")
  pivotTable: any;       // Drizzle pivot table
  relatedTable: any;     // Drizzle related entity table
  parentFk: any;         // Column on pivot for parent (e.g., artistSongs.song_id)
  relatedFk: any;        // Column on pivot for related (e.g., artistSongs.artist_id)
  bodyField: string;     // POST body field name (e.g., "artistId", "albumId", "promptId")
}
```

Relationship routes generate:
- `POST /:id/{slug}` -- Assign (validates parent exists, related exists, no duplicate; body: `{ [bodyField]: number }`)
- `PUT /:id/{slug}/:relatedId` -- Remove assignment (deletes pivot row)

## Registry

The registry (`routes/registry.ts`) defines all 13 entity-context configurations. It also contains all Zod schemas and enricher functions used by those configurations.

### Zod Schemas (defined in registry.ts)

| Schema | Fields |
|---|---|
| `createSongSchema` | name, isrc?, image_path?, release_date?, rating?, spotify_uid?, apple_music_uid?, youtube_uid? |
| `createArtistSchema` | name, isni?, image_path?, rating? |
| `createAlbumSchema` | name, ean?, image_path?, release_date?, rating?, spotify_uid?, apple_music_uid?, youtube_uid? |
| `createVibeSchema` | name, vibe_category, description?, instructions?, examples? |
| `createBinSourceSchema` | name, url |
| `createBinSongSchema` | name, asset_path?, lyrics?, notes?, rating?, bin_source_id? |
| `createPromptCollectionSchema` | name, description? |
| `createSunoPromptSchema` | name, lyrics?, prompt?, notes? |
| `createSunoSongPlaylistSchema` | name, description? |
| `createSunoSongSchema` | name, suno_uid, image_path?, suno_prompt_id?, bin_song_id?, suno_song_playlist_id? |

Each entity also has an explicit `update*Schema` defined as `create*Schema.partial().extend({ archived: z.boolean().optional() })`.

### The 13 Entity Configurations

| # | Route Path | Context Value | Table | Entity Name | Enrichers | Relationships | Extra Filters |
|---|---|---|---|---|---|---|---|
| 1 | `/my-music/songs` | `my_music` | `songs` | Song | list: artists, detail: artists+albums | artists, albums | -- |
| 2 | `/my-music/artists` | `my_music` | `artists` | Artist | -- | -- | -- |
| 3 | `/my-music/albums` | `my_music` | `albums` | Album | -- | -- | -- |
| 4 | `/lab/songs` | `lab` | `songs` | Song | list: artists, detail: artists+albums | artists, albums | -- |
| 5 | `/lab/artists` | `lab` | `artists` | Artist | -- | -- | -- |
| 6 | `/lab/albums` | `lab` | `albums` | Album | -- | -- | -- |
| 7 | `/lab/vibes` | `lab` | `vibes` | Vibe | -- | -- | `category` (eq) |
| 8 | `/bin/sources` | `bin` | `binSources` | Source | -- | -- | -- |
| 9 | `/bin/songs` | `bin` | `binSongs` | Bin Song | list: source, detail: source | -- | `bin_source_id` (eq) |
| 10 | `/suno/prompt-collections` | `suno` | `sunoPromptCollections` | Collection | detail: prompts | prompts | -- |
| 11 | `/suno/prompts` | `suno` | `sunoPrompts` | Prompt | -- | -- | -- |
| 12 | `/suno/song-playlists` | `suno` | `sunoSongPlaylists` | Playlist | -- | -- | -- |
| 13 | `/suno/songs` | `suno` | `sunoSongs` | Suno Song | -- | -- | -- |

### Enricher Functions (defined in registry.ts)

| Function | Used By | Description |
|---|---|---|
| `songListEnricher` | my-music/songs, lab/songs | Batch-loads artist names via `artist_songs` pivot for list rows |
| `songDetailEnricher` | my-music/songs, lab/songs | Loads related artists and albums for a single song |
| `binSongListEnricher` | bin/songs | Batch-loads source info for bin song list rows |
| `binSongDetailEnricher` | bin/songs | Loads source info for a single bin song |
| `collectionDetailEnricher` | suno/prompt-collections | Loads assigned prompts for a single collection |

### Shared Relationship Configs

The `songRelationships` array is reused by both `my-music/songs` and `lab/songs`:
- `artists`: pivot `artistSongs`, body field `artistId`
- `albums`: pivot `albumSongs`, body field `albumId`

The `suno/prompt-collections` config has its own relationship:
- `prompts`: pivot `sunoCollectionPrompts`, body field `promptId`

## Route Assembly

The route assembler (`routes/index.ts`) iterates the registry and mounts each entity:

```typescript
for (const config of registry) {
  const entityRouter = createEntityRoutes(config);
  routes.route(`/${config.context}/${config.slug}`, entityRouter);
}
```

Then mounts extension routes:
- `routes.route("/lab", labImport)` -- Handles `/lab/import` and `/lab/import/confirm`
- `routes.route("/upload", uploadRoutes)` -- Handles `POST /upload`
- `routes.route("/storage", storageRoutes)` -- Handles `GET /storage/*`

Finally defines `GET /dashboard/stats` inline, which counts all entities by section/context.

The entire routes object is mounted at `/api` in `app.ts` via `app.route("/api", routes)`.

## Route Conventions

### RESTful Patterns

All routes are mounted under `/api`. Route structure follows the pattern:

| Method | Path | Description |
|---|---|---|
| GET | `/api/{context}/{slug}` | List with pagination, filtering, search |
| POST | `/api/{context}/{slug}` | Create new record |
| GET | `/api/{context}/{slug}/:id` | Get single record (with enriched relations) |
| PUT | `/api/{context}/{slug}/:id` | Update record (including archive) |
| POST | `/api/{context}/{slug}/:id/{relSlug}` | Assign relationship |
| PUT | `/api/{context}/{slug}/:id/{relSlug}/:relatedId` | Remove relationship |

### No DELETE Endpoints

There are no DELETE endpoints. To "delete" a record, send a PUT request with `{ archived: true }`. This is enforced project-wide. The one exception is relationship removal (PUT on pivot routes), which physically deletes pivot rows.

### CORS

Only GET, POST, PUT, and OPTIONS methods are allowed:
```typescript
allowMethods: ["GET", "POST", "PUT", "OPTIONS"]
```

### Special Routes

- `GET /api/health` -- Health check (unauthenticated)
- `POST|GET /api/auth/*` -- Better Auth handler (unauthenticated)
- `GET /api/dashboard/stats` -- Dashboard statistics (counts for all entity types by section)
- `POST /api/lab/import` -- Spotify import preview
- `POST /api/lab/import/confirm` -- Spotify import confirm
- `POST /api/upload` -- File upload
- `GET /api/storage/*` -- File serving

### List Endpoint Query Parameters

All list endpoints accept standardized query parameters auto-generated by the factory's `buildListQuerySchema`:

| Parameter | Type | Default | Description |
|---|---|---|---|
| `page` | number | 1 | Page number (1-based) |
| `pageSize` | number (1-100) | 25 | Results per page |
| `sort` | string | varies | Column name to sort by (from `sortableColumns`) |
| `order` | "asc" \| "desc" | "desc" | Sort direction |
| `search` | string | -- | Text search (LIKE on configured search columns) |
| `archived` | "true" \| "false" | -- | Filter by archive status |
| + extra filters | varies | -- | Entity-specific (e.g., `category`, `song_id`, `bin_source_id`) |

### List Response Format

```json
{
  "data": [...],
  "total": 42,
  "page": 1,
  "pageSize": 25
}
```

## Validation

### Factory-Generated Validation

The route factory applies `@hono/zod-validator` automatically:
- **POST body**: `zValidator("json", config.createSchema)`
- **PUT body**: `zValidator("json", effectiveUpdateSchema)` (derived or explicit)
- **GET list query**: `zValidator("query", listSchema)` (auto-generated from config)
- **Relationship POST body**: `zValidator("json", z.object({ [bodyField]: z.number().int().positive() }))`

### Schema Location

All Zod schemas consumed by factory routes are defined in `routes/registry.ts`. Non-CRUD extension routes define their schemas inline (e.g., `importUrlSchema` in `routes/extensions/lab-import.ts`).

When adding new entities, define Zod schemas directly in `routes/registry.ts` alongside the entity configuration.

### Boolean Query Parameters

Never use `z.coerce.boolean()` for query string parameters. In JavaScript, `Boolean("false") === true`, so query param `?archived=false` would incorrectly match `true`. Instead use:
```typescript
z.enum(["true", "false"]).transform((v) => v === "true").optional()
```
This pattern is used in the factory's auto-generated `listQuerySchema`.

### Rating Scale

All rating fields in Zod schemas use `z.number().min(0).max(5).nullable().optional()`. The database stores ratings as `real` columns (0-1 scale). Applies to songs, artists, albums, and bin songs.

## Authentication

### Better Auth Setup

Authentication is handled by Better Auth configured in `auth/index.ts`:
- **Adapter**: Drizzle adapter with SQLite provider
- **Methods**: Email/password (always enabled) + Google OAuth (optional, enabled when credentials provided)
- **Session**: Cookie-based with 5-minute cookie cache
- **Tables**: user, session, account, verification (defined in `db/schema/auth.ts`)

### Auth Middleware

The auth middleware (`middleware/auth.ts`) runs on all `/api/*` routes with these exceptions:
- `/api/auth/*` routes are skipped (Better Auth handles its own authentication)
- `/api/health` is defined before the middleware and is unauthenticated

The middleware:
1. Checks for the dev bypass condition
2. Calls Better Auth's `getSession` API
3. Sets `user` and `session` context variables on the Hono context
4. Returns 401 if no valid session exists

### Rate Limiting

Auth endpoints (`/api/auth/*`) are protected by an in-memory rate limiter configured at 10 requests per 60 seconds per IP address. The middleware (`middleware/rate-limit.ts`):
- Tracks requests by IP using `X-Forwarded-For` or `X-Real-IP` headers
- Returns HTTP 429 with `Retry-After` header when the limit is exceeded
- Sets `X-RateLimit-Limit` and `X-RateLimit-Remaining` response headers
- Cleans up expired entries every 60 seconds to prevent memory leaks
- Uses an unreferenced timer so it does not prevent process exit
- Skipped entirely when `DEV_AUTH_BYPASS=true` and `NODE_ENV !== "production"` to avoid rate-limiting frequent `get-session` calls during development

### Dev Auth Bypass

For local development, authentication can be bypassed entirely. This requires a **double guard**:
- `DEV_AUTH_BYPASS=true` must be set in environment variables
- `NODE_ENV` must NOT be `"production"`

Both conditions must be true. If either is false, real authentication is required. The bypass injects a synthetic "Dev User" with ID `dev-user-1`. In bypass mode, `GET /api/auth/get-session` returns a fake session directly from `app.ts` without invoking Better Auth.

## Storage

### StorageClient Abstraction

All file operations go through the `StorageClient` interface (`services/storage/index.ts`):

```typescript
interface StorageClient {
  upload(path: string, data: Buffer | ArrayBuffer | ReadableStream, contentType: string): Promise<void>;
  download(path: string): Promise<ArrayBuffer>;
  getPublicUrl(path: string): string;
  exists(path: string): Promise<boolean>;
}
```

### Implementations

- **LocalStorageClient**: Writes to the local filesystem at `../../tmp/storage` (relative to API root). Serves files through `/api/storage/*`. Used when `STORAGE_PROVIDER=local`.
- **BunnyStorageClient**: Uses Bunny Edge Storage HTTP API for uploads/downloads and Bunny CDN for public URLs. Used when `STORAGE_PROVIDER=bunny`.

### Factory

Call `createStorageClient()` to get the correct implementation based on the `STORAGE_PROVIDER` environment variable. The factory validates that required Bunny credentials are present when using the Bunny provider.

### Upload Route

`POST /api/upload` accepts multipart form data with:
- `file` (required) -- The file to upload (max 10MB, allowed types: `image/*`, `audio/*`)
- `directory` (optional) -- One of: `artists`, `albums`, `songs`, `bin`

Returns `{ path: string, url: string }` (HTTP 201). Files are stored with timestamp+random unique filenames.

### Storage Route

`GET /api/storage/*` serves uploaded files with immutable cache headers. Supports image formats (JPEG, PNG, GIF, WebP, SVG, ICO) and audio formats (MP3, WAV, OGG, FLAC, AAC, M4A, WMA).

## Spotify Import Service

The Spotify metadata extraction service (`services/spotify/index.ts`) uses the `spotify-url-info` library to scrape public Spotify embed pages and extract track metadata without requiring Spotify API credentials.

### Public API

- `fetchSpotifyData(url: string): Promise<SpotifyImportResult>` -- Fetches metadata for a Spotify URL (track, album, or playlist). Returns normalized `SpotifyTrack` objects with name, artists, album, releaseDate, ISRC, imageUrl, and spotifyId.
- `detectSpotifyType(url: string): "track" | "album" | "playlist" | "unknown"` -- Detects the Spotify resource type from a URL path.

### Import Routes (extensions/lab-import.ts)

- `POST /api/lab/import` -- Preview: accepts a Spotify URL and returns extracted tracks for review. Validates URL with `importUrlSchema` (defined inline in `lab-import.ts`).
- `POST /api/lab/import/confirm` -- Confirm: accepts selected tracks and creates records in the `lab` context:
  - Creates `songs` records (context: `lab`) with duplicate detection by `spotify_uid` and `isrc`
  - Creates `artists` records (context: `lab`) with case-insensitive name matching
  - Creates `albums` records (context: `lab`) with case-insensitive name matching
  - Links via `artist_songs` and `album_songs` pivot tables
  - Downloads cover art images to storage and updates `image_path` on records
  - Image download failures do not block record creation

### Type Declarations

The `spotify-url-info` library lacks built-in types. Custom type declarations are in `types/spotify-url-info.d.ts`.

## Migration Workflow

1. **Edit schema**: Modify `src/db/schema.ts`
2. **Push locally**: `pnpm db:push` -- Applies changes directly to local SQLite (development only)
3. **Generate migration**: `pnpm db:generate` -- Creates SQL migration files from schema diff
4. **Commit**: Commit the schema changes and generated migration files
5. **Migrate production**: `pnpm db:migrate` -- Runs pending migrations on the production database

**CRITICAL**: Never run `drizzle-kit push` against production. Always use the generate + migrate workflow for production databases.

## OpenRouter Service

The OpenRouter service (`services/openrouter/index.ts`) is a minimal `fetch`-based wrapper for the OpenRouter chat completions API. Edge-compatible (no Node.js-specific APIs).

### Public API
- `chatCompletion(messages, options?)` -- Sends messages to the configured OpenRouter model. Returns the text content of the first choice. Throws if `OPENROUTER_API_KEY` is not set.

### Profile Generator Extension

Extension route at `routes/extensions/profile-generator.ts`. Mounted at `/api/profile-generator`.

**POST `/api/profile-generator/generate`**
- Accepts `{ songId: number }`
- Fetches the song, its artists, and all active vibes
- Builds a detailed prompt instructing the AI to analyze the song and produce vibe values
- Calls OpenRouter using `PROFILE_GENERATION_OPENROUTER_MODEL`
- Maps the AI response (vibe ID -> value) into a JSON array of `{ name, category, value }` objects using vibe metadata
- Inserts a `profiles` record with `method: "vibes"` and the JSON array as `value`
- Returns `{ data: { id, songId, method, totalVibes } }`

Error codes: 404 (song not found), 400 (no active vibes), 503 (env not configured), 502 (OpenRouter error), 422 (unparseable response)

### Profiles Extension

Extension route at `routes/extensions/profiles.ts`. Mounted at `/api/profiles`.

**PUT `/api/profiles/:id`**
- Accepts `{ archived: boolean }`
- Archives or restores a profile
- Returns `{ data: { id, archived } }`

### Suno Prompt Generator Extension

Extension route at `routes/extensions/suno-prompt-generator.ts`. Mounted at `/api/suno-prompt-generator`.

**POST `/api/suno-prompt-generator/generate-from-profile`**
- Accepts `{ profileId: number }`
- Fetches the profile, parses its JSON value (`Array<{ name, category, value }>`), fetches the linked song and artists
- Builds a detailed prompt instructing the AI to generate Suno-compatible lyrics and style
- Calls OpenRouter (using `VIBES_SUNO_PROMPT_OPENROUTER_MODEL`), parses JSON response (`{ lyrics, style }`)
- Creates a new `suno_prompts` record with the generated lyrics/style, linked to the source song via `song_id`
- Returns `{ data: { id, name, songId } }`

Error codes: 404 (profile or song not found), 400 (empty profile data), 422 (invalid JSON), 503 (env not configured), 502 (OpenRouter error)

## Testing

- Framework: Vitest
- Run: `pnpm test` (from API directory) or `pnpm test:api` (from root)
- Watch mode: `pnpm test:watch`
- Pattern: Use `app.request()` for route integration tests. Import the Hono app from `app.ts` and call `app.request(url, options)` to simulate HTTP requests without starting a server.

## Edge Deployment Constraints

The API deploys to Bunny Edge Scripting, which has specific constraints:

- **Bundle size limit**: 1MB maximum. The esbuild configuration produces a single bundled file.
- **No native Node.js modules**: Cannot use `fs`, `http`, `net`, or other Node-built-in modules in production. Use `fetch` for HTTP and `@libsql/client/web` for database access on the edge.
- **Web-compatible APIs only**: All code must work in a web-worker-like environment. The local dev server uses `@hono/node-server` but production runs in an edge runtime.
- **Database client**: Use `@libsql/client` (which supports both local file and remote libSQL). On the edge, the `/web` subpath import is used automatically.

## Environment Variables

All env variables are validated by the Zod schema in `src/env.ts`. No defaults -- all values must be set in the root `.env` file.

| Variable | Required | Description |
|---|---|---|
| NODE_ENV | Yes | Environment mode (development/production/test) |
| DATABASE_URL | Yes | SQLite file path or libSQL URL |
| DATABASE_AUTH_TOKEN | No | libSQL auth token (production) |
| BETTER_AUTH_SECRET | Yes | Auth encryption secret (min 16 chars) |
| BETTER_AUTH_URL | Yes | Auth base URL |
| GOOGLE_CLIENT_ID | No | Google OAuth client ID |
| GOOGLE_CLIENT_SECRET | No | Google OAuth client secret |
| STORAGE_PROVIDER | Yes | "local" or "bunny" |
| STORAGE_LOCAL_PATH | Yes | Local storage directory |
| BUNNY_STORAGE_ZONE | No | Bunny storage zone name |
| BUNNY_STORAGE_PASSWORD | No | Bunny storage access key |
| BUNNY_STORAGE_REGION | No | Bunny storage region hostname |
| BUNNY_CDN_HOSTNAME | No | Bunny CDN pull zone hostname |
| BUNNY_CDN_SECURITY_KEY | No | Bunny CDN security key |
| DEV_AUTH_BYPASS | No | Set "true" to bypass auth in dev |
| FRONTEND_URL | Yes | Frontend origin for CORS |
| OPENROUTER_API_KEY | No | OpenRouter API key (enables AI generation) |
| VIBES_SUNO_PROMPT_OPENROUTER_MODEL | No | OpenRouter model ID for Suno prompt generation |
| PROFILE_GENERATION_OPENROUTER_MODEL | No | OpenRouter model ID for profile generation |
